vocabulary V{
    type Colourâ‰œ {Blue, Red, Green, Yellow}
    type Node  â‰œ {A, B, C}              // a country on the map
    edge: Node â¨¯ Node â†’ ğ”¹    // Country X and Y are neighbors
    colouring: Node â†’ Colour // The color of X is Y
}

theory T:V{
    âˆ€ n, m âˆˆ Node: edge(n, m) â‡’ colouring(n) â‰  colouring(m).
}

structure S:V{

    edge â‰œ {(A, B), (B,C)}.
}






//het probleem hier is dat partiele functies precies moeilijk doen.
vocabulary V_draw{
    type shape â‰œ  constructed from {circ, rect, text, link, link_directed, img}
    type key âŠ†  â„¤
    type color â‰œ constructed from {black, blue, brown,red,green, slateGrey, snow, springGreen,
    steelBlue, tan, teal, thistle, tomato, turquoise, violet, wheat,white,
    whiteSmoke, yellow, yellowGreen}

    type width âŠ† â„¤
    type height âŠ† â„¤
    //type order âŠ† â„¤
    d3_width : ()â†’width
    d3_height: ()â†’height
    d3_type :partial key â†’ shape
    d3_x : partial key â†’ width
    d3_y : partial key â†’ height
    d3_color : partial key â†’ color
    //d3_order : partial key â†’ order
    d3_circ_r : partial key â†’ width
    d3_rect_width : partial key â†’ width
    d3_rect_height : partial key â†’ height

    d3_link_width : partial key â†’ width
    d3_link_from : partial key â†’ key
    d3_link_to : partial key â†’ key
    //d3_node(key)
    //d3_isFixed(key)
}

vocabulary V_combined{
    import V_draw
    import V

    node_to_key : Nodeâ†’key
    edge_to_key : partial Node â¨¯ Nodeâ†’key

    colour_to_color: Colourâ†’color



}

theory T_draw:V_combined{

    //// het "stuk dat eigenlijk in de aparte theorie moet zitten" gedeelte
    {
        edge(A,B).
        edge(B,C).
    }
    âˆ€ n, m âˆˆ Node: edge(n, m) â‡’ colouring(n) â‰  colouring(m).




    ////toKey functions

    //toKey function domain is edge
    âˆ€x,y âˆˆ Node: dom_edge_to_key(x,y) â‡” edge(x,y).


    //âˆ€n âˆˆ Node:dom_d3_type(node_to_key(n)) âˆ§ d3_type(node_to_key(n))=circ.
    //âˆ€n,n1 âˆˆ Node:dom_d3_type(edge_to_key(n,n1)) âˆ§ d3_type(edge_to_key(n,n1))=link.

    //injectivity of the functions
    âˆ€n1,n2 âˆˆ Node: node_to_key(n1)=node_to_key(n2) â‡’ n1=n2.
    âˆ€n1,n2,n3,n4 âˆˆ Node:dom_edge_to_key(n1,n2) âˆ§ dom_edge_to_key(n3,n4) âˆ§ edge_to_key(n1,n2) = edge_to_key(n3,n4) â‡’ n1=n3 âˆ§ n2=n4.

    //disjunct images
    âˆ€n,n1,n2 âˆˆ Node: dom_edge_to_key(n1,n2) â‡’ node_to_key(n) â‰  edge_to_key(n1,n2).



    //definition color
    {
        colour_to_color(Blue)=blue.
        colour_to_color(Red)=red.
        colour_to_color(Yellow)=yellow.
        colour_to_color(Green)=green.
    }


    //alle cirkels zijn 40 groot
    âˆ€c âˆˆ dom_d3_type: d3_type(c)=circ â‡’ dom_d3_circ_r(c) âˆ§ d3_circ_r(c)=40.


    //de nodes worden cirkels
    âˆ€n âˆˆ Node: dom_d3_type(node_to_key(n)) âˆ§ (d3_type(node_to_key(n)) = circ).

    //de edges worden links(beter als inductieve definitie maar partieelfunctie)
    âˆ€n1,n2 âˆˆ Node: edge(n1,n2) â‡’ dom_edge_to_key(n1,n2) âˆ§  dom_d3_type(edge_to_key(n1,n2)) âˆ§ d3_type(edge_to_key(n1,n2)) = link.


    //nodes coordinaten

    âˆ€n âˆˆ Node: dom_d3_x(node_to_key(n)) âˆ§ d3_x(node_to_key(n))=80â¨¯node_to_key(n).
    âˆ€n âˆˆ Node: dom_d3_y(node_to_key(n)) âˆ§ d3_y(node_to_key(n))=50.




    //nodes kleuren
    âˆ€n âˆˆ Node: dom_d3_color(node_to_key(n)) & d3_color(node_to_key(n))=colour_to_color(colouring(n)).



    //links linken de juiste nodes
    âˆ€n1,n2 âˆˆ Node: edge(n1,n2) â‡’ dom_edge_to_key(n1,n2) âˆ§ dom_d3_link_from(edge_to_key(n1,n2)) âˆ§ dom_d3_link_to(edge_to_key(n1,n2)) âˆ§ d3_link_from(edge_to_key(n1,n2))=node_to_key(n1) âˆ§ d3_link_to(edge_to_key(n1,n2))=node_to_key(n2).

    d3_width()=800.
    d3_height()=300.



}

structure S_draw:V_draw{
    width â‰œ {1..1000}.
    height â‰œ {1..1000}.
    key â‰œ {1..5}.



    //Colour â‰œ {blue, red, green, yellow}.
}

procedure main(){

    //pretty_print(model_expand(T, S))
    pretty_print(model_expand(T_draw, S_draw))
}